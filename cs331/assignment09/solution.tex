\documentclass{article}

\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}

\usepackage{tikz}

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0}
\newcounter{homeworkProblemCounter}

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{
    \stepcounter{homeworkProblemCounter}
    \renewcommand{\homeworkProblemName}{#1}
    \section{\homeworkProblemName}
    \enterProblemHeader{\homeworkProblemName}
}{
    \exitProblemHeader{\homeworkProblemName}
}

\newcommand{\problemAnswer}[1]{
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}}
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{
    \renewcommand{\homeworkSectionName}{#1}
    \subsection{\homeworkSectionName}
    \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]}
}{
    \enterProblemHeader{\homeworkProblemName}
}

\newcommand{\hmwkTitle}{Homework\ \#8}
\newcommand{\hmwkDueDate}{April 11, 2013 at 11:59pm}
\newcommand{\hmwkClass}{CS331}
\newcommand{\hmwkClassTime}{9:00am}
\newcommand{\hmwkClassInstructor}{Professor Zhang}
\newcommand{\hmwkAuthorName}{Josh Davis}

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
    \vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{}

\begin{document}

\maketitle

\pagebreak

\begin{homeworkProblem}
    \textbf{Part A} Prove that \(n! \in O(n^n)\).
    \\

    \begin{proof}
        To prove that \(n! \in O(n^n)\), we will use the definition of big-O
        which states: For two functions, \(f\) and \(g\). Say that \(f(n) =
        O(g(n))\) if positive integers \(c\) and \(n_0\) exist such that for
        every integer \(n \geq n_0\) that \(f(n) \leq cg(n)\).
        \\

        Thus we need to find a \(c\) and \(n_0\) to satisfy the above
        condition.
        \\

        Let \(f(n) = n! \) and \(g(n) = n^n\). Let \(c = 1\) and \(n_0 = 1\), so for
        all \(n \geq n_0\) we have:

        \[
            \begin{split}
                n! &= (n)(n - 1)(n - 2)\hdots(2)(1)
                \\
                &\leq c(n_n)(n_{n-1})(n_{n-2})\hdots(n_{2})(n_{1})
                \\
                &= cn^n
            \end{split}
        \]

        Since we have satisfied the definition of big-O, we can see that \(n!
        \in O(n^n)\) and thus our proof is complete.
    \end{proof}

    \textbf{Part B} Which of the following relations is true and which is false?

    \begin{enumerate}
        \item \(n \in O((\lg n)^3)\)
            \\
            \textbf{False}
            \\
            Linear functions outgrow polylogrithmic asymptotically. No such
            \(c\) or \(n_0\) to satisfy big-O definition.
        \item \((\lg n)^3 \in o(n)\)
            \\
            \textbf{True}
            \[
                \lim_{n \to \infty} \frac{(\lg n)^3}{n} = 0
            \]
        \item \(n^{\lg n} \in O(2^{n \lg n})\)
            \\
            \textbf{True}
            \[
                \begin{split}
                    n^{\lg n} &\leq c 2^{n \lg n}
                    \\
                    \lg n \lg n &\leq c(\lg 2)(n \lg n)
                    \\
                    \lg n \lg n &\leq c(n \lg n)
                    \\
                    \lg n &\leq cn
                \end{split}
            \]
            We can pick \(c = 1\) and \(n_0 = 1\), thus it is true.
        \item \(n^4 \in o(100n^4)\)
            \\
            \textbf{False}
            \[
                    \lim_{n \to \infty} \frac{n^4}{100n^4}
                    = \lim_{n \to \infty} \frac{1}{100}
                    = \frac{1}{100}
            \]
        \item \((\lg n)^n \in O(\sqrt{2^n})\)
            \\
            \textbf{False}
            \[
                \begin{split}
                    n(\lg n)^n &\leq c\sqrt{2^n}
                    \\
                    n(\lg \lg n) &\leq \frac{c}{2}\lg(2^n)
                    \\
                    n(\lg \lg n) &\leq \frac{c}{2}n
                    \\
                    (\lg \lg n) &\leq \frac{c}{2}
                \end{split}
            \]
            Which is clearly false, no constant is less than any function with \(n\).
    \end{enumerate}
\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
    Prove that any language in \(P\) is \textbf{polynomial reducible} to any
    language in \(P\) which is not \(\emptyset\) or \(\Sigma^*\).

    \begin{proof}
        To prove that any language in \(P\) is polynomial reducible to any
        other language in \(P\), we will do a proof by construction to
        construct a polynomial time mapping function \(f\) that maps one
        language to another.
        \\

        Let there be two languages \(A\) and \(B\) that are both in \(P\).
        Since they are in \(P\) we know there are two TMs that run in
        polynomial time. Let these TMs be \(M_1\) and \(M_2\).
        \\

        We will now construct a polynomial reducible function where \(w \in A \iff f(w) \in B\).
        Let this function be computed by a TM \(N\) which is as follows:
        \\

        \(N = \)`` On input \(\langle M, w \rangle\) where \(M\) is a TM and \(w\) a string:
        \begin{enumerate}
            \item Construct a new TM, \(M'\):
                \\
                \(M' = \)`` On input \(w\):
                \begin{enumerate}
                    \item Compute \(M_1\) on input \(w\) to find a value in \(A\)
                    \item Simulate \(M_2\) on newly computed value outputting
                        what \(M_2\) does to find a value in \(B\)
                \end{enumerate}
            \item Output \(\langle M' \rangle\).''
        \end{enumerate}

        As we can see, since \(A\) and \(B\) are both in \(P\), we can use the TMs
        that recognize the languages to reduce \(A\) to \(B\).
        \\

        \textbf{Note:} \(\emptyset\) and \(\Sigma^*\) can't be reduced to. If
        we have a language \(A\) that has some \(w\) that it accepts and some
        that it rejects, trying to reduce to \(\emptyset\) is impossible
        because since there exists a \(w \in A\), there is no way to map it to
        \(\emptyset\) because the condition \(w \in A \iff f(w) \in B\) doesn't
        hold. The converse is true for \(\Sigma^*\) as well. If \(w \not\in A\)
        we can't map it to a value that isn't in \(\Sigma^*\). Thus we exclude
        these two languages from our proof.
    \end{proof}
\end{homeworkProblem}

\begin{homeworkProblem}
    Let \(L = \{0^i 1^j : i > j\}\). Show that \(L \in TIME(n \lg n)\).

    \begin{proof}
        To show that \(L \in TIME(n \lg n)\), we will use a proof by construction to construct
        a new TM \(M\) that only uses \(TIME(n \lg n)\) steps to complete.
        \\

        \(M = \)`` On input string \(w\):
        \begin{enumerate}
            \item Start on the left side of the word, scan left, if there is a 1 before a 0, \(reject\)
            \item Repeat as long as there are 0s still on the tape:
                \begin{enumerate}
                    \item Scan across the tape, if there are 0s left and no more 1s left, \(accept\)
                    \item Scan again, crossing off every other 0 and every other 1
                \end{enumerate}
            \item Since there are no more 0s, and we haven't accepted, we know \(i \leq j\), thus \(reject\).''
        \end{enumerate}

        Let's analyze the running time of \(M\). First observe that every stage
        except for the last run in \(TIME(n)\). Stage 2 halfs the number of
        characters in the input every time it repeats thus it runs in \(TIME(n)
        * TIME(\lg n)\). The total running time is then \(TIME(n) + TIME(n \lg
        n)\).  This gives us the final running time of \(TIME(n \lg n)\).
    \end{proof}
\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
    Prove that Graph isomorphism is in \(NP\). That is
    \[
        GI = \{\langle G, H \rangle : G, H \mbox{are isomorphic}\} \in NP
    \]

    Two graphs \(G = \langle V_G, E_G \rangle\) and \(H = \langle V_H, E_H \rangle\) are isomorphic
    iff there is a bijection \(f : V_G \rightarrow V_H\) such that \(\langle v, v' \rangle \in E_G\)
    if and only if \(\langle f(v), f(v') \rangle \in E_H\).

    \begin{proof}
        To show that graph isomorphism is in \(NP\), we will construct a verifier that can
        verify the problem in polynomial time. This proves that a language is in \(NP\) because
        of \textbf{Theorem 7.20}.
        \\

        The verifier \(V\) that verifies that a graph is isomorphic is as follows:
        \\

        \(V = \)`` On input \(\langle \langle G, H \rangle, c \rangle\):
        \begin{enumerate}
            \item Check that \(c\) is a valid bijection from nodes in \(G \rightarrow H\)
            \item For every \((v_1, v_2) \in c\):
                \begin{enumerate}
                    \item Check that \(v_1 \in G\)
                    \item Check that \(v_2 \in H\)
                \end{enumerate}
            \item If everything passes, \(accept\), otherwise \(reject\).''
        \end{enumerate}

        We can see that given our input, \(\langle G, H \rangle\) where \(n =
        \left\vert G \right\vert\) and \(m = \left\vert H \right\vert\), we can
        see that the verifier's time complexity is running in \(O(m + n)\)
        time, or \(2n = O(n)\) because the number of nodes in the graphs must
        be equal.
        \\

        Thus we have proven that Graph Isomorphism is in \(NP\).
    \end{proof}
\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
    Prove that Double Satisfaction Problem, defined as
    \[
        SAT2 = \{ \langle \phi \rangle : \phi \mbox{ is a 3CNF-formula with at least two solutions}\}
    \]

    is \(NP\)-complete.

    \begin{proof}
        To prove that \(SAT2\) is \(NP\)-complete, we will first show that it
        is in \(NP\) and then reduce \(3SAT\) to it. Similar to what is done in
        \textbf{Corollary 7.42} in the textbook.
        \\

        To show that \(SAT2\) is in \(NP\), we can just create a TM that
        guesses two assignments to all the variables and then tries them. This
        TM would be nondeterministic but could run in polynomial time. Thus
        \(SAT2 \in NP\).
        \\

        Given a \(\phi \in 3SAT\), we know that \(\phi\) is a 3cnf-formula that
        is satisfiable once.  Now we can just make a dummy variable say \(j\)
        and add it along with another variable \(x\) so that \(\phi' = \phi
        \wedge (j \vee \overline{j} \vee x)\). Thus we can see that for any
        assignment of \(j\), it is satisfied twice because it was already
        satisfied once.
        \\

        This construction is very easily polynomial time. Now we need to show
        that if \(\phi \not\in 3SAT\), using our reduction, \(\phi' \not\in
        SAT2\).
        \\

        Given a \(\phi \not\in 3SAT\), we know that there is no such assignment
        that satisfies it.  Thus when using our reduction, \(\phi' = \phi
        \wedge (j \vee \overline{j} \vee x)\). This will never result in having
        two satisfactions for it because the previous part is not satisfied.
        \\

        Thus we have shown that \(SAT2\) is \(NP\)-complete and our proof is finished.
    \end{proof}
\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
    Prove that the class \(P\) is closed under union and complementation.
    \\

    \textbf{Part One} Prove that \(P\) is closed under union.

    \begin{proof}
        To prove that \(P\) is closed under union, we assume that there are two languages
        \(L_1\) and \(L_2\) with \(M_1\) and \(M_2\) as TMs that decide them.
        \\

        Assume that \(M_1\) runs in polynominal time, \(O(n^x)\) as well as
        \(M_2\), \(O(n^y)\).
        \\

        We will construct a new TM \(M\) that runs both \(M_1\) and \(M_2\) and show that it still
        runs in polynomial time.
        \\

        \(M = \)`` On input \(w\):
        \begin{enumerate}
            \item Run \(M_1\) on \(w\).
            \item Run \(M_2\) on \(w\).
            \item If one of the TMs accepted, accept, else reject.''
        \end{enumerate}

        The runtime of \(M\) can be determined as \(O(n^x) + O(n^y)\). Asymptotically,
        this is equal to the following: \(O(n^{z})\) where \(z = max(x, y)\).
        \\

        Thus we can see that P is closed under union.
    \end{proof}

    \textbf{Part Two} Prove that \(P\) is closed under complementation.

    \begin{proof}
        To prove that \(P\) is closed under complementation, we assume that there is a
        language \(L\) with a TM \(M\) that decides it.
        \\

        Assume that \(M\) runs in polynominal time, \(O(n^x)\).
        \\

        We will construct a new TM \(N\) that runs \(M\) and we will
        show that it still runs in polynomial time.
        \\

        \(N = \)`` On input \(w\):
        \begin{enumerate}
            \item Run \(M\) on \(w\).
            \item If \(M\) accepted, reject, else accept.''
        \end{enumerate}

        The construction of \(N\) is such that it decides the complement of the
        language that \(M\) decides. This TM also runs in \(O(n^x)\), which
        means it still runs in polynomial time.
        \\

        Thus we can see that P is closed under complementation.

    \end{proof}
\end{homeworkProblem}

\end{document}
