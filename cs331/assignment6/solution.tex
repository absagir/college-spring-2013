\documentclass{article}

\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}

\usetikzlibrary{automata,positioning,calc}

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0}
\newcounter{homeworkProblemCounter}

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{
    \stepcounter{homeworkProblemCounter}
    \renewcommand{\homeworkProblemName}{#1}
    \section{\homeworkProblemName}
    \enterProblemHeader{\homeworkProblemName}
}{
    \exitProblemHeader{\homeworkProblemName}
}

\newcommand{\problemAnswer}[1]{
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}}
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{
    \renewcommand{\homeworkSectionName}{#1}
    \subsection{\homeworkSectionName}
    \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]}
}{
    \enterProblemHeader{\homeworkProblemName}
}

\newcommand{\hmwkTitle}{Homework\ \#6}
\newcommand{\hmwkDueDate}{March 14, 2013 at 11:59pm}
\newcommand{\hmwkClass}{CS331}
\newcommand{\hmwkClassTime}{9:00am}
\newcommand{\hmwkClassInstructor}{Professor Zhang}
\newcommand{\hmwkAuthorName}{Josh Davis}

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
    \vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{}

\begin{document}

\maketitle

\pagebreak

\begin{homeworkProblem}
    Let \(\Sigma = \{0, 1\}\). Consider the following language over \(\Sigma\),
    \[
         L = \{w_1 \# w_2 : w_1 w_2, \in \{0, 1\}^* \mbox{ and } w_1 < w_2 \}
    \]

    Design a Turing machine using pseudocode that recognizes \(L\).
    \\

    \(M = \)`` On input string \(w\):
    \begin{enumerate}
        \item Start on the left side of the word, move all the way to the right of the input, move to stage \(loop_{>}\)
        \item \textbf{\(loop_>\)} Move to the first character in the second word that isn't an x.  If on 0, mark
            with x and move to stage \textbf{\(cmp_{<0}\)}. If on 1, mark with x and move to \textbf{\(cmp_{>1}\)}.
            If on \textvisiblespace, move to \(q_{reject}\). If on \#, move to stage \textbf{check}.
        \item \textbf{\(loop_<\)} If on 0, mark with x and move to stage \textbf{\(cmp_{>0}\)}. If on 1, mark with x
            and move to \textbf{\(cmp_{<1}\)}. If on \textvisiblespace, move to \(q_{accept}\)
        \item \textbf{\(cmp_{<0}\)} Move to the first character in the first word that isn't an x. If 1, mark with x
            and move to \text{\(loop_>\)}. If 0, mark with x and move to \text{\(loop_<\)}. If \textvisiblespace, move
            to \textbf{\(loop_<\)}.
        \item \textbf{\(cmp_{<1}\)} Move to the first character in the first word that isn't an x. If 1, mark with x
            and move to \text{\(loop_<\)}. If 0, mark with x and move to \text{\(loop_<\)}. If \textvisiblespace,
            move to \textbf{\(loop_<\)}.
        \item \textbf{\(cmp_{>0}\)} Move to the first character in the first word that isn't an x. If 1, mark with x
            and move to \text{\(loop_>\)}. If 0, mark with x and move to \text{\(loop_>\)}. If \textvisiblespace, move
            to \textbf{\(loop_>\)}.
        \item \textbf{\(cmp_{>1}\)} Move to the first character in the first word that isn't an x. If 1, mark with x
            and move to \text{\(loop_>\)}. If 0, mark with x and move to \text{\(loop_<\)}. If \textvisiblespace, move
            to \textbf{\(loop_>\)}.
        \item \textbf{check} Move to first character in the first word that isn't an x. If 1, move to \(q_{reject}\).
        If 0, move to stage \textbf{check}. If \textvisiblespace, move to \(q_{accept}\).''
    \end{enumerate}

    This is valid because we can split up the input into four cases which each have two sub-cases as follows:
    \\
    \textbf{Case One} Input is \(0 w_1 \# 0 w_2\):

    \begin{enumerate}
        \item If \(w_1 < w_2\), then \(w_1 < w_2\)
        \item If \(w_1 > w_2\), then \(w_1 > w_2\)
    \end{enumerate}

    \textbf{Case Two} Input is \(0 w_1 \# 1 w_2\):

    \begin{enumerate}
        \item If \(w_1 < w_2\), then \(w_1 < w_2\)
        \item If \(w_1 > w_2\), then \(w_1 < w_2\)
    \end{enumerate}

    \textbf{Case Three} Input is \(1 w_1 \# 0 w_2\):

    \begin{enumerate}
        \item If \(w_1 < w_2\), then \(w_1 > w_2\)
        \item If \(w_1 > w_2\), then \(w_1 > w_2\)
    \end{enumerate}

    \textbf{Case Four} Input is \(1 w_1 \# 1 w_2\):

    \begin{enumerate}
        \item If \(w_1 < w_2\), then \(w_1 < w_2\)
        \item If \(w_1 > w_2\), then \(w_1 > w_2\)
    \end{enumerate}

    Thus when the word ends, we just accept if we still satisfy \(w_1 < w_2\).
    \\

    \textbf{Note} When a given word runs out of characters, we just treat it if it had
    0's appended to the beginning such that the length of the words are equal.
\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
    Prove that 2-dimensional Turing machines are no more powerful than standard Turing
    machines.

    \begin{proof}
    \end{proof}
\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
    Prove that the class of Turing-recognizable languages are closed under certain operations.

    \textbf{Part One} Union: \(L = L_1 \cup L_2\)
    \begin{proof}
        Given two Turing machines, \(M_1\) and \(M_2\) that recognize the languages \(L_1\)
        and \(L_2\), respectively, we will construct a new Turing machine, \(M\), that recognizes
        the union of the two languages.
    \end{proof}

    \textbf{Part Two} Intersection: \(L = L_1 \cap L_2\)
    \begin{proof}
        Given two Turing machines, \(M_1\) and \(M_2\) that recognize the languages \(L_1\)
        and \(L_2\), respectively, we will construct a new Turing machine, \(M\), that recognizes
        the intersection of the two languages.
        \\

        Let \(M_1\) and \(M_2\) be defined as follows:
        \[
            \begin{split}
                M_1 = (Q_1, \Sigma_1, \Gamma_1, \delta_1, q_{M10}, q_{M1accept}, q_{M1reject})
                \\
                M_2 = (Q_2, \Sigma_2, \Gamma_2, \delta_2, q_{M20}, q_{M2accept}, q_{M2reject})
            \end{split}
        \]

        We can then construct \(M\) as follows:

        \begin{enumerate}
            \item \(Q = Q_0 \times Q_1\), the state machine
            \item \(\Sigma = \Sigma_1 \cup \Sigma_2\), the alphabet
            \item \(\Gamma = \Gamma_1 \cup \Gamma_2 \), the stack alphabet
            \item \(q_{0} = (q_{M10}, q_{M20}\), the start state is the state for both TMs
            \item Next we have to implement the transition function, \(\delta_M\),
                A Turing machine can do two movements on the tape, Left and Right. To replicate
                this with the 2-PDA, whenever the \(M\) is supposed to move to the left, we can
                just pop the value off the left stack and push it onto the right stack. Trivially
                we can do the same for moving right, pop off the right and push to the left.
                \\

                To handle writing new values to the tape, instead of pushing the value that
                was just popped, we can push any value such that value is in \(\Gamma\), the
                stack alphabet.
        \end{enumerate}
    \end{proof}

    \textbf{Part Three} Concatentation: \(L = L_1 * L_2\)
    \begin{proof}
        Given two Turing machines, \(M_1\) and \(M_2\) that recognize the languages \(L_1\)
        and \(L_2\), respectively, we will construct a new Turing machine, \(M\), that recognizes
        the concatentation of the two languages.
    \end{proof}
\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
    Let \(L\) be the language of \(\Sigma = \{0, 1\}\). Prove that \(L\)
    is Turing-decidable if and only if \(L\) can be enumerated by an enumerator
    Turing machine in strictly increasing order.

    \begin{proof}
        This proof will consist of two parts. First proving that any \(L\)
        that is Turing-decidable can be enumerated by an enumerator Turing machine
        in strictly increasing order. The second part is that an enumerator Turing machine
        in strictly increasing order gives a language, \(L\), that is Turing-decidable.
        \\

        \textbf{Part One}
        Proving that if a language is Turing-decidable, it can be enumerated by
        an enumerator Turing machine in strictly increasing order.
        \\

        Let the Turing-decidable language be \(L\) decided by \(M\) and the enumerator 
        Turing machine be \(E\).
        \\

        We can use \(M\) to help us in the construction of \(E\).
        \\

        Since \(L\) is the language decided by \(M\), let the lexographic
        ordering of the strings be denoted as \(s_1, s_2, s_3, \hdots\).
        We can then define \(E\) as follows:

        \(E = \)`` On input string \(s\):
        \begin{enumerate}
            \item For input, \(i = 1, 2, 3, \hdots\)
            \item Let \(M\) run on the string, \(s_i\)
            \item If \(M\) accepts the string, \(s_i\), print it.
            \item If \(M\) rejets the string, continue through the loop''
        \end{enumerate}

        This concludes the first part of the proof.
        \\

        \textbf{Part Two}
        Proving that if an enumerator Turing machine can enumerate a language
        in strictly increasing order, then it is Turing-decidable.
        \\

        Let the Turing-decidable language be \(L\) decided by \(M\) and the enumerator 
        Turing machine be \(E\).
        \\

        There are two cases to consider, when \(L\) is finite and when it is infinite.
        \\

        When it is finite, it has to be decidable. Every finite language can be decided.
        \\

        When it is inifinte, we can use \(E\) to help us in the construction of \(M\).
        \\

        The pseudo-code that describes \(M\) is as follows:

        \(M = \)`` On input string \(w\):
        \begin{enumerate}
            \item Receive input from \(E\), \(s\)
            \item If \(s\) is the same as \(w\), accept it
            \item If \(s\) is lexicographically larger than \(w\), reject it
            \item If \(s\) is lexicographically smaller than \(w\), go back to stage 1''
        \end{enumerate}

        This works because \(w\) is guaranteed to be in \(L\) because it is infinite.
        \\

        This concludes the second part of the proof. Thus both sides have been proven and
        the proof is complete.
    \end{proof}
\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
    Prove that any Turing machine can be simulated by a 2-PDA.

    \begin{proof}
        To prove that any Turing machine can be simulated by a 2-PDA, we will
        use a proof by construction. We will construct a Turing machine, \(M\), where
        \[
            M = \langle Q_M, \Sigma_M, \Gamma_M, q_{M0}, q_{accept}, q_{reject} \rangle
        \] 

        such that it is constructed from a 2-PDA, \(M\), where

        \[
            P = \langle Q_P, \Sigma_P, \Gamma_P, \delta_P, q_{P0}, F_P \rangle
        \]

        \(M\) will be defined as follows:

        \begin{enumerate}
            \item \(Q_M = Q_P\), the state machine is preserved
            \item \(\Sigma_M = \Sigma_P\), the alphabets are identical
            \item \(\Gamma_M = \Gamma_P \cap \{\textvisiblespace\} \), the stack alphabet
            \item \(q_{M0} = q_{P0}\), the start states are the same
            \item Next we have to implement the transition function, \(\delta_M\),
                A Turing machine can do two movements on the tape, Left and Right. To replicate
                this with the 2-PDA, whenever the \(M\) is supposed to move to the left, we can
                just pop the value off the left stack and push it onto the right stack. Trivially
                we can do the same for moving right, pop off the right and push to the left.
                \\

                To handle writing new values to the tape, instead of pushing the value that
                was just popped, we can push any value such that value is in \(\Gamma\), the
                stack alphabet.
        \end{enumerate}

        The reason this works is because the first stack can be viewed as everything to
        the left of the read/write head, while everything on the second stack can be
        viewed as everything to the right of the read/write head. Since stacks are infinite
        in PDA's, two of them can represent the tape in a Turing machine.
        \\

        It follows that a Turing machine can be simulated using a 2-PDA and
        thus the proof is complete.

    \end{proof}
\end{homeworkProblem}

\end{document}
