My reason for designing things the way I did was to make it easy to add new types of Objects and Properties to the Simulation without having to edit any of the source code.
I did this by subclassing ISimObject to create SimEntity which holds either a property or an object. Properties are unique in that they either affect the ISee or IProbe while Objects act directly on the Robot. For example, Fog alters the sight of the robot if it's in the same square while Water takes away energy when a robot enters the square. Whenever a robot wants to move, the simulation will check the square it is in to see if it should alter the probing or the robot's sight and use that to get the robot's move. Then when a robot moves, it will let all of the objects in the square act on it. Although I think it works for the most part, it did cause a few minor issues.

The Simulation class is used in all 3 of the executables. It can check a config, simulate it, and also programmatically generate one.

I wanted to make each Object/Property handle it's own variable setting, so I created the setValueForProperty method. It takes in two strings and returns a 1 if the property string isn't valid for the object and a 0 if it worked fine. It really helped to cut down on error checking.

SearchRobot: My robot that searches for the Energy Pills doesn't quite work right.. The idea is to search all of the open squares and never die but it kind of just ends up running into a wall. The logic is all there, it just never correctly maps out where it has and has not been. It probably is a couple hour fix however.

Note: All of the documentation for classes are in the header files. Any class that inherits from another has the documentation is in superclass header. For example, for all of the methods inherited by my Objects, they are documented in the Interfaces.h in the IEnvObject declaration. All methods have code throughout to explain the algorithm/what's going on
